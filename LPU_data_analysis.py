import pandas as pd
import numpy as np
import numpy.polynomial.polynomial as poly
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import scipy.integrate as integrate
from scipy.optimize import fsolve
from math import sqrt

plt.style.use('ggplot')
mu = '\u03BC'


# Random functions
def scal(alist, B, E, v):
    # returns a list of stiffness given a list of ahat values
    slist = []
    for a in alist:
        Cv = cf(a)
        C = Cv/(B*E/(1-v**2))
        slist.append(1/C*1e-3)
    return slist


# Creating stiffness and modulus lists from separated partial loading and unloading curves
# Main function: sepfread
# Helper functions: stifflist, modlist, convertSS
def stifflist(dfg):
    slist = []
    for n in range(2,len(dfg)-1, 3):
        data = np.array(dfg[n])
        x = data[-100:,2] #for cases where the unloading curve is not straight at the beginning
        y = data[-100:,3] 
        a, b = poly.polyfit(x, y, 1)
        d = np.max(data[:,3])
        row = np.where(data[:,3]==d)
        c = data[row,2]
        slist.append([a,b,c,d])
    return np.array(slist)


def modlist(dfg):
    slist = []
    for n in range(2,len(dfg)-1, 3):
        data = np.array(dfg[n])
        x = data[-100:,4]
        y = data[-100:,5]
        a, b = poly.polyfit(x, y, 1)
        slist.append([a,b])
    return np.array(slist)


def convertSS(df, C1, C2, L, W, B):
    d = np.array(df.iloc[:,0].values)
    P = np.array(df.iloc[:,1].values)
    P -= P[0]
    if C2 == 0:
        d -= P/C1
    else:
        d -= (-C1 + np.sqrt(C1**2 + 4*C2*P))/(2*C2) # '+' is used instead of '-' because P here should be -P
    df.insert(2, 'depth (nm)', d)
    if L != None and W != None and B != None:
        d = d/1000
        strain = W*d/L**2
        stress = 12*P*L/(B*W**2)
        df.insert(3, 'stress (MPa)', stress)
        df.insert(3, 'strain', strain)
    df.insert(3, f"load ({mu}N)", P)
    return 


def sepfread(file, C1, C2, L=None, W=None, B=None):
    file = Path(file)
    df = pd.read_csv(file, 
                     sep='\t', 
                     skip_blank_lines=False, 
                     header=3, 
                     usecols=[0,1], 
                     encoding='ANSI')
    df.loc[:,'group_no'] = df.isnull().all(axis=1).cumsum()
    df.loc[0,'group_no'] = 1
    df = df.dropna()
    convertSS(df, C1, C2, L, W, B)
    dfg = [x for _, x in df.groupby('group_no')]
    s = stifflist(dfg)
    sdf = pd.DataFrame(s, columns=['Intercept', 'Stiffness ({mu}N/nm)', 'Displacement at Max Load (nm)', 'Max Load ({mu}N)'])
    sfilename = file.stem + '_s.csv'
    sdf.to_csv(file.parent/sfilename, index=False)
    if L != None and W != None and B != None:
        e = modlist(dfg)
        edf = pd.DataFrame(e, columns=['Intercept', 'Modulus (MPa)'])
        efilename = file.stem + '_e.csv'
        edf.to_csv(file.parent/efilename, index=False)
    dffilename = file.stem + '_df.csv'
    df.to_csv(file.parent/dffilename, index=False)
    return
    
# R-curve analysis: finding load and Area under the curve
# Main function: createpAlist
# Helper function: findpA
def findpAloading(arr):
    if arr.shape[0] < 11:
        return 0, 0, 0
    def func(x, m, c):
        return m * x + c
    def func2(y, m, c):
        return (y - c)/ m
    xval = arr[:,-3]
    yval = arr[:,-2]
    p= np.max(yval)
    popt, pcov = curve_fit(func, xval, yval)
    m, c = popt
    x0 = func2(0, m, c)
    x1 = func2(p, m, c)
    A, err = integrate.quad(lambda x: m * x + c, x0, x1) 
    return x1, A, err


def findpAholding(arr, x0):
    if arr.shape[0] < 11:
        return 0, 0, 0
    def func(x, m, c):
        return m * x + c
    def func2(y, m, c):
        return (y - c)/ m
    xval = arr[:,-3]
    yval = arr[:,-2]
    p= np.max(yval)
    popt, pcov = curve_fit(func, xval, yval)
    m, c = popt
    x1 = func2(p, m, c)
    A, err = integrate.quad(lambda x: m * x + c, x0, x1) 
    return p, A, err


def createpAlist(file):
    '''

    Parameters
    ----------
    file : df csv file generated by sepfread function

    Returns
    -------
    df2 : Dataframe containing the maximum loads and area under the loading and holding curves of the respective test

    '''
    pAlist = []
    df = pd.read_csv(file)
    df.dropna(inplace=True)
    dfg = [x for _, x in df.groupby('group_no')]
    for n in range(0,len(dfg)-1, 3):
        data = np.array(dfg[n])
        x0, A1, err1 = findpAloading(data)
        data2 = np.array(dfg[n+1])
        p, A2, err2= findpAholding(data2, x0)
        pAlist.append([p, A1 + A2, err1 + err2])
    result = np.array(pAlist)
    df2 = pd.DataFrame(result, columns=['p', 'A', 'A err'])
    return df2


# R-curve analysis: creating Dataframe with crack length, J-Integral and Qualified Fracture Toughness values
# Main function: rCurve
# Helper functions: finda, createK, createJ
def finda(cf, c, B, E, v, a0hat):
    d = {}
    Cv = c*B*E/(1-v**2)
    exec(f"def func1(x): return {cf} - {Cv}", globals(), d)
    roots = float(fsolve(d['func1'], [a0hat], maxfev=1000, factor=0.1))
    return roots


def createK(p, B, W, gf, a):
    d = {}
    exec(f"def func2(x): return {gf}", globals(), d)
    f = d['func2'](a)
    return f, p/(B*W**0.5)*f


def createJ(W, B, a0, a1, k, E, v, A, a, aprev):
    b = a*B*(W-a1)/(W*(a1-a0))
    bprev = aprev*B*(W-a1)/(W*(a1-a0))
    j = (k**2)*(1-v**2)/E + (2*2.0*A)/(a*b-aprev*bprev)
    return [a*b-aprev*bprev, j]


def initialA(x, y, m, c):
    '''
    Parameters
    ----------
    x : List of x coordinates
    y : List of y coordinates
    m : Final slope
    c : Final y-intercept

    Returns
    -------
    Acorr : Corrected Area
    xint : Final x-intercept\
    '''
    A = integrate.trapz(y, x)
    yend = y[-1]
    Acorr, xint = corrinitialA(A, c, m, yend)
    return Acorr, xint


def corrinitialA(A, c, m, y1):
    '''
    Parameters
    ----------
    A : Uncorrected area under the p-d curve
    c : y-intercept of the best fit line of the unloading curve
    m : stiffness (i.e. gradient of the unloading curve)
    y1 : Max load right before unloading

    Returns
    -------
    Corrected area under the load displacement curve
    '''
    x0 = -c/m
    x1 = (y1-c)/m
    x = x1-x0
    Achg = 0.5*y1*x
    return A-Achg, x0


def rCurve(csv): 
    '''
    Parameters
    ----------
    csv : csv file containing all the input values to calculate the r curve

    Returns
    -------
    df : Dataframe containing all the j values to plot the r-curve

    '''
    rcur = []
    prevsample = ""
    aprev = 0
    df = pd.read_csv(csv)
    df.dropna(inplace=True)
    narr = np.array(df)
    for row in narr:
        sample, notch, material, W, B, a0, a1, s, p, A, cf, gf, E, v = row
        if prevsample != sample:
            aprev = 0
        c = 1/s*1e-3
        ahat = finda(cf, c, B, E, v, a0/W)
        if ahat < a0/W or ahat > a1/W:
            rcur.append([sample, c, E, v, p, ahat, 0, 0, 0, 0, 0, 0])
            continue
        fa, k = createK(p, B, W, gf, ahat)
        a = ahat*W - a0
        if a < 0:
            a = 0
        notcharea, j = createJ(W, B, a0, a1, k, E, v, A, a, aprev)
        kq = np.sqrt(j*E/(1-v**2))
        rcur.append([sample, c, E, v, p, ahat, a, fa, k, notcharea, j, kq])
        aprev = a
        prevsample = sample     
    rcarr = np.array(rcur)
    df = pd.DataFrame(rcarr, columns=['Sample', 'Compliance (um/uN)', 'Modulus (MPa)', 
                                       'Poisson\'s Ratio', 'Max Load (uN)', 'a_hat', 'aj (um)',
                                       'Geometric Factor', 'kj (kPa m^0.5)', 'Notch Area (um^2)',
                                       'J-Integral (J/m^2)', 'Kq (kPa m^0.5)'])
    return df

    
# Plotting functions
def plotcurve(file, cno1, cno2):
    file = Path(file)
    df = pd.read_csv(file, usecols=[cno1,cno2])
    plt.plot(df.iloc[:,0], df.iloc[:,1])
    return


def plotplulsep(file): #Note: use the df file converted by sepfread
    df = pd.read_csv(file, 
                     sep=',')
    dfg = [x for _, x in df.groupby('group_no')]
    s = stifflist(dfg)
    i = 1
    for n in dfg:
        seq = (i-4)%3+1
        if seq == 1: 
            x = n.iloc[:,2]
            y = n.iloc[:,3]
            plt.plot(x,y, 'r.')
        elif seq == 2:
            x = n.iloc[:,2]
            y = n.iloc[:,3]
            plt.plot(x,y, 'g.')
        if seq == 3: 
            x = n.iloc[:,2]
            y = n.iloc[:,3]
            plt.plot(x,y, 'b.')
            print(i)
        i += 1
    d = 2
    plt.show()
    return


def find1stpt(file):
    dat = []
    df = pd.read_csv(file, 
                     sep=',')
    dfg = [x for _, x in df.groupby('group_no')]
    for i in range(2, len(dfg)-1, 3):
        x0 = dfg[i].iloc[0,2]
        y0 = dfg[i].iloc[0,3]
        dat.append([x0, y0])
    datnp = np.array(dat)
    return datnp


def plot1stpt(datnp):
    plt.plot(datnp[:,0], datnp[:,1], 'kx')
    for n in np.arange(len(datnp)):
        plt.annotate(str(n), (datnp[n, 0], datnp[n,1]))
    

def findx0(x, y, m):
    c = y-m*x
    x0 = -c/m
    return x0


def plotMeasureCurve(xlsf, startpt, endpt):
    df = pd.read_excel(xlsf)
    datnp = np.array(df)
    plt.plot(datnp[startpt+1:endpt+2,1], datnp[startpt+1:endpt+2,3], '-kx', ms=10.0, linewidth=2.0)
    for n in range(startpt,endpt+1):  
        plt.plot([datnp[n + 1, 7]*1000, datnp[n + 1, 1]], [0, datnp[n + 1, 3]], '--y', linewidth=1.0)
